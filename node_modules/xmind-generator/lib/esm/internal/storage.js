export function makeImageResourceStorage() {
  const resourceStorage = {};
  return {
    storage: resourceStorage,
    set: async (resource) => {
      const resourcePath = await computeResourcePath(resource);
      resourceStorage[resourcePath] = resource.data;
      return resourcePath;
    },
    get: (resourcePath) => {
      return resourceStorage[resourcePath] ?? null;
    }
  };
}
export async function computeResourcePath(resource) {
  const hash = await generateSHA256Hash(resource.data);
  const extname = fileExtname(resource.name);
  return extname ? `${hash}.${extname}` : hash;
}
function fileExtname(fileName) {
  return fileName.lastIndexOf(".") !== -1 ? fileName.substring(fileName.lastIndexOf(".") + 1) : "";
}
async function generateSHA256Hash(data) {
  if (typeof window !== "undefined" && typeof crypto !== "undefined") {
    const encoder = new TextEncoder();
    const dataBuffer = typeof data === "string" ? encoder.encode(data) : data;
    return crypto.subtle.digest("SHA-256", dataBuffer).then((hashBuffer) => {
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const hashHex = hashArray.map((byte) => byte.toString(16).padStart(2, "0")).join("");
      return hashHex;
    });
  } else {
    const crypto2 = await import("crypto");
    const hash = crypto2.createHash("sha256");
    if (data instanceof ArrayBuffer) {
      const textDecoder = new TextDecoder("utf-8");
      const text = textDecoder.decode(data);
      hash.update(text);
    } else {
      hash.update(Buffer.from(data));
    }
    return hash.digest("hex");
  }
}
